var geometric = function(p) {
  return flip(p) ? geometric() + 1 : 0;
}

var Geometric = function(p) {
  Infer({method: 'enumerate', maxExecutions: 10}, function() {
    geometric(p)
  })
}

var utterances = ['zop', 'zopudon', 'zopekil']
var meanings = ['zopudon', 'zopekil']

var S0 = function(m, params) {
  Infer({method: 'enumerate'}, function() {
    var u = categorical({vs: utterances, ps: params['pUtterances']})
    return u
  })
}


var litMeaning = cache(function(u, m) {
  return u == 'zop' ? true : u == m
})

var L0 = cache(function(u, params) {
	Infer({method: 'enumerate'}, function() {
      var m = categorical({vs: meanings, ps: params['pMeanings']})
      condition(litMeaning(u, m))
      return m
    })
})

var S1 = cache(function(m, params) {
	Infer({method: 'enumerate'}, function()  {
      var u = categorical({vs: utterances, ps: params['pUtterances']})
      var L = L0(u, params)
      factor(params['alpha'] * L.score(m))
      return u
    })
})

var L1 = cache(function(u, params) {
	Infer({method: 'enumerate'}, function() {
      var m = categorical({vs: meanings, ps: params['pMeanings']})
      var S = S1(m, params)
      factor(S.score(u))
      return m
    })
})

var S2 = cache(function(m, params) {
	Infer({method: 'enumerate'}, function()  {
      var u = categorical({vs: utterances, ps: params['pUtterances']})
      var L = L1(u, params)
      factor(params['alpha'] * L.score(m))
      return u
    })
})

var getSubjParams = mem(function(subjId) {
  return {
    'conditionType': uniformDraw(['combined', 'accuracy', 'time', 'neither']),
    'alpha': uniformDraw(_.range(1, 10)),
    'attention': beta(5, 1)
  }
})

var getSpeaker = cache(function(conditionType) {
  var speakers = {
    'combined': [S2, {'pUtterances': [10, 1, 1], 'pMeanings': [24, 8]}],
    'conventionalized': [S2, {'pUtterances': [10, 1, 1], 'pMeanings': [8, 24]}],
    'accuracy': [S2, {'pUtterances': [1, 1, 1], 'pMeanings': [24, 8]}],
    'time': [S0, {'pUtterances': [10, 1, 1], 'pMeanings': [24, 8]}],
    'neither': [S0, {'pUtterances': [1, 1, 1], 'pMeanings': [24, 8]}]
  }
  return speakers[conditionType]
})

// var S = getSpeaker('combined')[0]
// var params = getSpeaker('combined')[1]
var propIsShort = function(utterances) {
  return sum(map(function(x) {return x == 'zop'}, utterances))
}

var runExperiment = function(subjParams, displayType, n) {
  // Get subject strategy (condition)
  var conditionType = subjParams['conditionType']
  // Get subject alpha
  var alpha = subjParams['alpha']
  // Get subject attention
  var attention = subjParams['attention']
  var speaker = getSpeaker(conditionType)[0]
  var params = _.merge(getSpeaker(conditionType)[1], {'alpha': alpha})
  var meaning = displayType == 'frequent' ? 'zopudon' : 'zopekil'
  var speak = function() {
    return flip(attention) ?
      sample(speaker(meaning, params)) : 
      categorical({vs: utterances, ps: params['pUtterances']}) // Random choice of utterance
  }
  var utterances = repeat(n, speak)
  return propIsShort(utterances)
}

// var runSubjectOpts = {'method': 'rejection', 'samples': 500}
// var runSubjectOpts = {'method': 'enumerate'}
var runSubjectOpts = {'method': 'MCMC', 'samples': 750}
var runSubject = cache(function(subjId, alpha, conditionType, attention, displayType, n) {
  Infer(runSubjectOpts, function() {
    var params = {
      'alpha': alpha,
      'conditionType': conditionType,
      'attention': attention
    }
    return runExperiment(params, displayType, n)
  })
})

var opts = {method: 'MCMC', 'samples': 100, kernel: {HMC: {steps: 2, stepSize: 0.5}}, callbacks: [editor.MCMCProgress()]}
// var opts = {method: 'MCMC', 'samples': 1000, callbacks: [editor.MCMCProgress()]}
var opts = {method: "MCMC",
            onlyMAP:true, 
            samples: 100, 
            burn: 10,
            callbacks: [editor.MCMCProgress()]};
var results = function(subjId, countFrequent, countInfrequent) {
  Infer(opts, function() {
    var conditionType = uniformDraw(['combined', 'accuracy', 'time', 'neither', 'conventionalized'])
    var alpha = uniformDraw(_.range(1, 10))
    var attention = beta(5, 1)
    var recursiveDepth = sample(Geometric(0.3))
    observe(runSubject(subjId, alpha, conditionType, attention, 'frequent', 24), countFrequent)
    observe(runSubject(subjId, alpha, conditionType, attention, 'infrequent', 8), countInfrequent)
    return {'alpha': alpha, 
            'conditionType': conditionType, 
            'attention': attention}
  })
}


var rData = [
  {"Unnamed: 0":0,
   "IP":"100.10.40.83",
   "condition":"combined",
   "display_type":"frequent",
   "prop_long":0,
   "prop_short":24},
  {"Unnamed: 0":1,
   "IP":"100.2.122.157",
   "condition":"combined",
   "display_type":"frequent",
   "prop_long":2,
   "prop_short":23},
  {"Unnamed: 0":2,
   "IP":"104.11.62.66",
   "condition":"accuracy",
   "display_type":"frequent",
   "prop_long":8,
   "prop_short":0},
  {"Unnamed: 0":3,
   "IP":"104.174.222.43",
   "condition":"combined",
   "display_type":"frequent",
   "prop_long":8,
   "prop_short":0},
  {"Unnamed: 0":4,
   "IP":"104.175.214.163",
   "condition":"accuracy",
   "display_type":"frequent",
   "prop_long":8,"prop_short":0}]

var res = mapData({data: rData}, function(datum) {
  console.log(datum.IP)
  results(datum.IP, datum.prop_short, datum.prop_long)
})

viz.marginals(res[0])
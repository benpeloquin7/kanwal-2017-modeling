/***
Scenarios
=========

Combined: Costs and accuracy pressure
  + priors are [0.75, 0.25]
  + costs are relative to length
  + alpha is inferred
  [X] Data seems to make sense

Accuracy: No cost difference in sending names
  + costs are 0
  [X] Data seems to make sense

Time: No communicative partner (remove priors, but include costs) -- everyone uses zop
  + No communicative act so remove literal semantics (uniformDraw in all cases)

Neither: No communicative partner, no cost
  + remove literal semantics
  + costs are 0


***/


// Alpha
var alphas = _.range(1, 20)
var alphaDistr = Categorical({ps:repeat(alphas.length, function() {return 1}), vs:alphas})
var alphaPrior = function() { 
  return sample(alphaDistr)
}

// Costs
var costTypes = ['present', 'not_present', 'reversed']
var costsTypeDistr = Categorical({vs:costTypes, ps:[1, 1, 1]})
var costsTypePrior = function() {
  return sample(costsTypeDistr)
}
var getCosts = function(costType){
  if (costType == 'present') {
    return {
        'zop': 0.3,
        'zopekil': 0.7,
        'zopudon': 0.7
      }
  } else if (costType == 'not_present') {
    return {
        'zop': 0.0,
        'zopekil': 0.0,
        'zopudon': 0.0
      }
  } else if (costType == 'reversed') {
    return {
        'zop': 0.7,
        'zopekil': 0.3,
        'zopudon': 0.3
      }
  }
}

// Semantics
var semanticsTypes = ['present', 'not_present']
var semanticsTypesDistr = Categorical({vs: semanticsTypes, ps: [1, 1]})
var semanticsTypesPrior = function() {
  return sample(semanticsTypesDistr)
}

// Recursion
var recursionLevels = [1, 2]
var recursionLevelsDistr = Categorical({vs: recursionLevels, ps: [1, 1]})
var recursionLevelsPrior = function() {
  return sample(recursionLevelsDistr)
}

// need probability priors
var needProbTypes = ['present', 'not_present', 'reversed']
var needProbTypesDistr = Categorical({vs: needProbTypes, ps: [1, 1, 1]})
var needProbTypesPrior = function() {
  return sample(needProbTypesDistr)
}


//  Strategies
var combination = {
  "alpha": 6,
  "costsType": "present",
  "semanticsType": "present",
  "recursionLevel": 2,
  "priors": "present"
}

var accuracy = {
  "alpha": 12,
  "costsType": "not_present",
  "semanticsType": "present",
  "recursionLevel": 1,
  "priors": "present"
}

var time = {
  "alpha": 6,
  "costsType": "present",
  "semanticsType": "not_present",
  "recursionLevel": 1,
  "priors": "not_present"
}

var neither = {
  "alpha": 6,
  "costsType": "not_present",
  "semanticsType": "not_present",
  "recursionLevel": 2,
  "priors": "not_present"
}

var other = {
  "alpha": 10,
  "costsType": "present",
  "semanticsType": "present",
  "recursionLevel": 2,
  "priors": "reversed"
}

var model = function(d) {
  var _model = function() {
    
    
    // Infer params
    var alpha = alphaPrior()
    var costsType = costsTypePrior()
    var semanticsType = semanticsTypesPrior()
    var recursionLevel = recursionLevelsPrior()
    var needProbType = needProbTypesPrior()

    // Utteranecs
    var utterances = ['zop', 'zopekil', 'zopudon']
    var utterancesDistr = Categorical({vs:utterances, ps:[1, 1, 1]})
    var utterancesPrior = function() { 
      return sample(utterancesDistr)
    }

    // Worlds
    var getNeedProbWeights = function(needProbType) {
      if (needProbType == 'present') {
        return [24, 8]
      } else if (needProbType == 'not_present') {
        return [1, 1]
      } else if (needProbType == 'reversed') {
        return [8, 24]
      }
    }
    var worldsPriorWeights = getNeedProbWeights(needProbType)
    var worlds = [{'d':'zopudon'}, {'d':'zopekil'}]
    var worldsDistr = Categorical({vs: worlds, ps: worldsPriorWeights})
    var worldsPrior = function() { 
      return sample(worldsDistr)
    }

    var cost = function(utterance, costsType) {
      var costs = getCosts(costsType)
      return costs[utterance]
    }

    var utteranceMeaning = function(u, semanticsType) {
      if (semanticsType == "present") {
        if (u == 'zop') {
          return uniformDraw(['zopekil', 'zopudon'])
        } else {
          return u
        } 
      } else if (semanticsType == "not_present") {
        return uniformDraw(['zopekil', 'zopudon'])
      } else {
        console.log("Error bad semantics type:", semanticsType)
      }
    }

    var litMeaning = function(utterance, world) {
      return utterance == world['d']
    }

    var L0 = cache(function(utterance) {
      Infer({
        model() {
          var world = worldsPrior()
          var meaning = litMeaning(utteranceMeaning(utterance, semanticsType), world)
          factor(meaning ? 0 : -Infinity)
          return world
        }
      })
    })

    var S1 = cache(function(world) {
      Infer({
        model() {
          var utterance = utterancesPrior()
          var L = L0(utterance)
          factor(alpha * (L.score(world) - cost(utterance, costsType)))
          return utterance
        }
      })
    })

    var L1 = cache(function(utterance) {
      Infer({
        model() {
          var world = worldsPrior()
          var meaning = litMeaning(utteranceMeaning(utterance, semanticsType), world)
          var S = S1(world)
          factor(S.score(utterance))
          return world
        }
      })
    })

    var S2 = cache(function(world) {
      Infer({
        model() {
          var utterance = utterancesPrior()
          var L = L1(utterance)
          factor(alpha * (L.score(world) - cost(utterance, costsType)))
          return utterance
        }
      })
    })

    var getModel = function(recursionLevel) {
      if (recursionLevel == 1) {
        return S1
      } else if (recursionLevel == 2) {
        return S2
      }
    }

    var runSpeaker = function(n, typ) {
      Infer({
        method: "MCMC", 
        samples: 200, 
        burn: 50,
        model() {
          var _getProportion = function(data, target) {
            return filter(function(x) {return x == target}, data).length / data.length
          }
          var Model = getModel(recursionLevel)
          var world = typ == 'frequent' ? {d:'zopudon'} : {d:'zopekil'}
          var data = repeat(n, function() {
            return sample(Model(world))
          })
          var prop = _getProportion(data, 'zop')
          return prop
        }
      })
    }

    var frequent_prop = d['frequent']
    var infrequent_prop = d['infrequent']
    observe(runSpeaker(100, 'frequent', recursionLevel, semanticsType), frequent_prop)
    observe(runSpeaker(100, 'infrequent', recursionLevel, semanticsType), infrequent_prop)
    return {'alpha': alpha, 
            'costsType': costsType, 
            'recursionLevel': recursionLevel,
            'semanticsType': semanticsType,
            'needProbType': needProbType }
  }
  return _model
}

var opts = { method: "MCMC",
            onlyMAP:true, 
            callbacks: [editor.MCMCProgress()], 
            samples: 100, 
            burn: 20 };

// viz.table(Infer(opts,
//                 model({'IP': '24.20.229.200',
//                        'condition': 'combined',
//                        'frequent': 0.55,
//                        'infrequent': 0.1})))

var experimentalData = [
  {'IP': '100.10.40.83',
  'condition': 'combined',
  'frequent': 1.0,
  'infrequent': 0.0},
 {'IP': '100.2.122.157',
  'condition': 'combined',
  'frequent': 0.96,
  'infrequent': 0.0},
 {'IP': '104.174.222.43',
  'condition': 'combined',
  'frequent': 0.0,
  'infrequent': 0.5},
 {'IP': '107.161.163.8',
  'condition': 'combined',
  'frequent': 0.08,
  'infrequent': 0.0}]

var res = map(function(x) {
  console.log('IP', x['IP'])
  var currModel = model(x)
  var currPosterior = Infer(opts, currModel)
  var currAlpha = sample(marginalize(currPosterior, function(x) {
    return x['alpha']
  }))
  var currCostsType = sample(marginalize(currPosterior, function(x) {
    return x['costsType']
  }))
  var recursionLevel = sample(marginalize(currPosterior, function(x) {
    return x['recursionLevel']
  }))
  var semanticsType = sample(marginalize(currPosterior, function(x) {
    return x['semanticsType']
  }))
  var needProbType = sample(marginalize(currPosterior, function(x) {
    return x['needProbType']
  }))
  
  return {'IP': x['IP'],
          'alpha': currAlpha,
          'costsType': currCostsType,
          'recursionLevel': recursionLevel,
          'semanticsType': semanticsType,
          'needProbType': needProbType
         }
}, experimentalData)
res